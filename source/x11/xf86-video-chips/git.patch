diff --git a/configure.ac b/configure.ac
index 225e516..c0ed508 100644
--- a/configure.ac
+++ b/configure.ac
@@ -44,9 +44,6 @@ XORG_DEFAULT_OPTIONS
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 
-# Checks for programs.
-AM_PROG_CC_C_O
-
 AH_TOP([#include "xorg-server.h"])
 
 # Define a configure option for an alternate module directory
diff --git a/man/chips.man b/man/chips.man
index 740af38..0c022ee 100644
--- a/man/chips.man
+++ b/man/chips.man
@@ -165,9 +165,6 @@ Force the use of memory mapped IO where it can be used. Default: off
 Force driver to leave centering and stretching registers alone. This
 can fix some laptop suspend/resume problems. Default: off
 .TP
-.BI "Option \*qOverlay\*q"
-Enable 8+24 overlay mode.  Only appropriate for depth 24.  Default: off.
-.TP
 .BI "Option \*qColorKey\*q \*q" integer \*q
 Set the colormap index used for the transparency key for the depth 8 plane
 when operating in 8+16 overlay mode.  The value must be in the range
diff --git a/src/Makefile.am b/src/Makefile.am
index 0ebf7ea..b7daac0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -52,4 +52,5 @@ chips_drv_la_SOURCES = \
 	 ct_pcirename.h \
          ct_regs.c \
          ct_shadow.c \
-         ct_video.c
+         ct_video.c \
+         compat_api.h
diff --git a/src/compat-api.h b/src/compat-api.h
new file mode 100644
index 0000000..6bc946f
--- /dev/null
+++ b/src/compat-api.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2012 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Dave Airlie <airlied@redhat.com>
+ */
+
+/* this file provides API compat between server post 1.13 and pre it,
+   it should be reused inside as many drivers as possible */
+#ifndef COMPAT_API_H
+#define COMPAT_API_H
+
+#ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
+#define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
+#define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
+#endif
+
+#ifndef XF86_HAS_SCRN_CONV
+#define xf86ScreenToScrn(s) xf86Screens[(s)->myNum]
+#define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
+#endif
+
+#ifndef XF86_SCRN_INTERFACE
+
+#define SCRN_ARG_TYPE int
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrn = xf86Screens[(arg1)]
+
+#define SCREEN_ARG_TYPE int
+#define SCREEN_PTR(arg1) ScreenPtr pScreen = screenInfo.screens[(arg1)]
+
+#define SCREEN_INIT_ARGS_DECL int i, ScreenPtr pScreen, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL int arg, pointer blockData, pointer pTimeout, pointer pReadmask
+#define BLOCKHANDLER_ARGS arg, blockData, pTimeout, pReadmask
+
+#define CLOSE_SCREEN_ARGS_DECL int scrnIndex, ScreenPtr pScreen
+#define CLOSE_SCREEN_ARGS scrnIndex, pScreen
+
+#define ADJUST_FRAME_ARGS_DECL int arg, int x, int y, int flags
+#define ADJUST_FRAME_ARGS(arg, x, y) (arg)->scrnIndex, x, y, 0
+
+#define SWITCH_MODE_ARGS_DECL int arg, DisplayModePtr mode, int flags
+#define SWITCH_MODE_ARGS(arg, m) (arg)->scrnIndex, m, 0
+
+#define FREE_SCREEN_ARGS_DECL int arg, int flags
+
+#define VT_FUNC_ARGS_DECL int arg, int flags
+#define VT_FUNC_ARGS pScrn->scrnIndex, 0
+
+#define XF86_SCRN_ARG(x) ((x)->scrnIndex)
+#else
+#define SCRN_ARG_TYPE ScrnInfoPtr
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrn = (arg1)
+
+#define SCREEN_ARG_TYPE ScreenPtr
+#define SCREEN_PTR(arg1) ScreenPtr pScreen = (arg1)
+
+#define SCREEN_INIT_ARGS_DECL ScreenPtr pScreen, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL ScreenPtr arg, pointer pTimeout, pointer pReadmask
+#define BLOCKHANDLER_ARGS arg, pTimeout, pReadmask
+
+#define CLOSE_SCREEN_ARGS_DECL ScreenPtr pScreen
+#define CLOSE_SCREEN_ARGS pScreen
+
+#define ADJUST_FRAME_ARGS_DECL ScrnInfoPtr arg, int x, int y
+#define ADJUST_FRAME_ARGS(arg, x, y) arg, x, y
+
+#define SWITCH_MODE_ARGS_DECL ScrnInfoPtr arg, DisplayModePtr mode
+#define SWITCH_MODE_ARGS(arg, m) arg, m
+
+#define FREE_SCREEN_ARGS_DECL ScrnInfoPtr arg
+
+#define VT_FUNC_ARGS_DECL ScrnInfoPtr arg
+#define VT_FUNC_ARGS pScrn
+
+#define XF86_SCRN_ARG(x) (x)
+
+#endif
+
+#endif
diff --git a/src/ct_accel.c b/src/ct_accel.c
index 3920b0a..e349baf 100644
--- a/src/ct_accel.c
+++ b/src/ct_accel.c
@@ -46,9 +46,6 @@
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that use XAA need this */
 #include "xf86fbman.h"
 
@@ -174,7 +171,7 @@ Bool
 CTNAME(AccelInit)(ScreenPtr pScreen)
 {
     XAAInfoRecPtr infoPtr;
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSACLPtr cAcl = CHIPSACLPTR(pScrn);
 
@@ -428,19 +425,7 @@ chips_imagewrite:
         infoPtr->ImageWriteFlags |= NO_PLANEMASK;
 #endif
 
-
-#ifdef CHIPS_HIQV
-    if (XAAInit(pScreen, infoPtr)) {
-	if (cPtr->Flags & ChipsOverlay8plus16)      
-	    return(XAAInitDualFramebufferOverlay(pScreen,
-						 CTNAME(DepthChange)));
-	else
-	    return TRUE;
-    } else
-	return FALSE;
-#else
     return(XAAInit(pScreen, infoPtr));
-#endif
 }
 
 #ifdef CHIPS_HIQV
@@ -1243,11 +1228,6 @@ CTNAME(SubsequentScreenToScreenColorExpandFill)(ScrnInfoPtr pScrn,
 #endif
     w *= cAcl->BytesPerPixel;
     ctBLTWAIT;
-#ifdef CHIPS_HIQV
-    if ((y >= pScrn->virtualY) && (cPtr->Flags & ChipsOverlay8plus16) &&
-	    (pScrn->depth == 8))
-	ctSETPITCH(cAcl->PitchInBytes << 1, cAcl->PitchInBytes);
-#endif
     ctSETSRCADDR(srcaddr);
     ctSETDSTADDR(destaddr);
 #ifdef CHIPS_HIQV
@@ -1271,10 +1251,6 @@ CTNAME(SetupForColor8x8PatternFill)(ScrnInfoPtr pScrn, int patx, int paty,
     patternaddr = (paty * pScrn->displayWidth + 
 		   (patx & ~0x3F)) * cAcl->BytesPerPixel;
     cAcl->patternyrot = (patx & 0x3F) >> 3;
-#ifdef CHIPS_HIQV
-    if (cPtr->Flags & ChipsOverlay8plus16)
-	patternaddr += cPtr->FbOffset16;
-#endif
 
     ctBLTWAIT;
     ctSETPATSRCADDR(patternaddr);
@@ -1338,10 +1314,7 @@ CTNAME(SetupForMono8x8PatternFill)(ScrnInfoPtr pScrn, int patx, int paty,
 
 #ifdef CHIPS_HIQV
     patternaddr = paty * pScrn->displayWidth + patx;
-    if (cPtr->Flags & ChipsOverlay8plus16)
-	patternaddr = patternaddr * 2 + cPtr->FbOffset16;
-    else
-	patternaddr *= cAcl->BytesPerPixel;
+    patternaddr *= cAcl->BytesPerPixel;
 #else
     patternaddr = (paty * pScrn->displayWidth + patx) * cAcl->BytesPerPixel;
 #endif
@@ -1593,10 +1566,7 @@ CTNAME(WritePixmap)(ScrnInfoPtr pScrn, int x, int y, int w, int h,
     dwords = (((skipleft  + bytesPerLine + 0x7) & ~0x7)) >> 2;
     destaddr = (y * pScrn->displayWidth + x) * (bpp >> 3);
     destpitch = pScrn->displayWidth * (bpp >> 3);
-    if ((y >= pScrn->virtualY) && (cPtr->Flags & ChipsOverlay8plus16))
-	destaddr += cPtr->FbOffset16;
-    else
-	destaddr += cAcl->FbOffset;
+    destaddr += cAcl->FbOffset;
 
     ctBLTWAIT;
 
@@ -1681,10 +1651,7 @@ CTNAME(WritePixmap)(ScrnInfoPtr pScrn, int x, int y, int w, int h,
 	y++;
 
 	destaddr = (y * pScrn->displayWidth + x) * (bpp >> 3);
-	if ((y >= pScrn->virtualY) && (cPtr->Flags & ChipsOverlay8plus16))
-	    destaddr += cPtr->FbOffset16;
-	else
-	    destaddr += cAcl->FbOffset;
+	destaddr += cAcl->FbOffset;
 
 	ctBLTWAIT;
 	ctSETDSTADDR(destaddr);
@@ -1717,10 +1684,7 @@ CTNAME(ReadPixmap)(ScrnInfoPtr pScrn, int x, int y, int w, int h,
     dwords = (((bytesPerLine + 0x7) & ~0x7)) >> 2;
     srcaddr = (y * pScrn->displayWidth + x) * (bpp >> 3);
     srcpitch = pScrn->displayWidth * (bpp >> 3);
-    if ((y >= pScrn->virtualY) && (cPtr->Flags & ChipsOverlay8plus16))
-	srcaddr += cPtr->FbOffset16;
-    else
-	srcaddr += cAcl->FbOffset;
+    srcaddr += cAcl->FbOffset;
 
     ctBLTWAIT;
     ctSETROP( ctDSTSYSTEM | ctLEFT2RIGHT | ctTOP2BOTTOM | 
@@ -1755,10 +1719,7 @@ CTNAME(ReadPixmap)(ScrnInfoPtr pScrn, int x, int y, int w, int h,
 	dst += dstwidth;
 	y++;
 	srcaddr = (y * pScrn->displayWidth + x) * (bpp >> 3);
-	if ((y >= pScrn->virtualY) && (cPtr->Flags & ChipsOverlay8plus16))
-	    srcaddr += cPtr->FbOffset16;
-	else
-	    srcaddr += cAcl->FbOffset;
+	srcaddr += cAcl->FbOffset;
 	ctBLTWAIT;
 	ctSETSRCADDR(srcaddr);
 	ctSETHEIGHTWIDTHGO(h, bytesPerLine);
diff --git a/src/ct_bank.c b/src/ct_bank.c
index d79e2f4..0264616 100644
--- a/src/ct_bank.c
+++ b/src/ct_bank.c
@@ -47,9 +47,6 @@
 /* Everything using inb/outb, etc needs "compiler.h" */
 #include "compiler.h"
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
@@ -63,13 +60,13 @@
 #define arm32_drain_writebuf()
 #endif
 
-#define ChipsBank(pScreen) CHIPSPTR(xf86Screens[pScreen->myNum])->Bank
+#define ChipsBank(pScreen) CHIPSPTR(xf86ScreenToScrn(pScreen))->Bank
 
 #ifdef DIRECT_REGISTER_ACCESS
 int
 CHIPSSetRead(ScreenPtr pScreen, int bank)
 { 
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
 
@@ -88,7 +85,7 @@ CHIPSSetRead(ScreenPtr pScreen, int bank)
 int
 CHIPSSetWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));
 
@@ -107,7 +104,7 @@ CHIPSSetWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));
@@ -126,7 +123,7 @@ CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
 
@@ -144,7 +141,7 @@ CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));
 
@@ -162,7 +159,7 @@ CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));
@@ -181,7 +178,7 @@ CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetRead(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
@@ -204,7 +201,7 @@ CHIPSWINSetRead(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));
@@ -226,7 +223,7 @@ CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
@@ -250,7 +247,7 @@ CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
@@ -272,7 +269,7 @@ CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));
@@ -294,7 +291,7 @@ CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
@@ -318,7 +315,7 @@ CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, (((bank & 0x7F) << 8) | 0x0E));
 
@@ -336,7 +333,7 @@ CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSHiQVSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     outw(cPtr->PIOBase + 0x3D6, ((((bank << 2) & 0x7F) << 8) | 0x0E));
 
@@ -356,7 +353,7 @@ CHIPSHiQVSetReadWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSSetRead(ScreenPtr pScreen, int bank)
 { 
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
 
@@ -375,7 +372,7 @@ CHIPSSetRead(ScreenPtr pScreen, int bank)
 int
 CHIPSSetWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));
 
@@ -394,7 +391,7 @@ CHIPSSetWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
     cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));
@@ -413,7 +410,7 @@ CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
 
@@ -431,7 +428,7 @@ CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));
 
@@ -449,7 +446,7 @@ CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
   
     cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
     cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));
@@ -468,7 +465,7 @@ CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetRead(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
   
     cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
@@ -490,7 +487,7 @@ CHIPSWINSetRead(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));
@@ -511,7 +508,7 @@ CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
@@ -533,7 +530,7 @@ CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
@@ -554,7 +551,7 @@ CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));
@@ -575,7 +572,7 @@ CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
     register unsigned char tmp;
 
     cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
@@ -597,7 +594,7 @@ CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
 int
 CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     cPtr->writeXR(cPtr, 0x0E, bank & 0x7F);
 
@@ -615,7 +612,7 @@ CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
 int
 CHIPSHiQVSetReadWritePlanar(ScreenPtr pScreen, int bank)
 {
-    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
+    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
 
     cPtr->writeXR(cPtr, 0x0E, (bank << 2) & 0x7F);
 
diff --git a/src/ct_cursor.c b/src/ct_cursor.c
index cc352d3..2bf04f2 100644
--- a/src/ct_cursor.c
+++ b/src/ct_cursor.c
@@ -36,9 +36,6 @@
 /* Everything using inb/outb, etc needs "compiler.h" */
 #include "compiler.h"   
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
@@ -434,7 +431,7 @@ CHIPSLoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
 static Bool
 CHIPSUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
 {
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     
     return (((cPtr->Flags & ChipsHWCursor) != 0)
@@ -444,7 +441,7 @@ CHIPSUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
 Bool
 CHIPSCursorInit(ScreenPtr pScreen)
 {
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     xf86CursorInfoPtr infoPtr;
 
diff --git a/src/ct_ddc.c b/src/ct_ddc.c
index ab02d47..5e2346a 100644
--- a/src/ct_ddc.c
+++ b/src/ct_ddc.c
@@ -10,9 +10,6 @@
 /* Everything using inb/outb, etc needs "compiler.h" */
 #include "compiler.h"
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
@@ -96,7 +93,7 @@ chips_ddc1(ScrnInfoPtr pScrn)
 	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "DDC1 found\n");	
     else return;
 
-    xf86PrintEDID(xf86DoEDID_DDC1(pScrn->scrnIndex, vgaHWddc1SetSpeedWeak(),
+    xf86PrintEDID(xf86DoEDID_DDC1(XF86_SCRN_ARG(pScrn), vgaHWddc1SetSpeedWeak(),
 				  chips_ddc1Read));
 
     /* restore */
diff --git a/src/ct_dga.c b/src/ct_dga.c
index 32f3aa3..b2f8ded 100644
--- a/src/ct_dga.c
+++ b/src/ct_dga.c
@@ -6,7 +6,6 @@
 #include "xf86.h"
 #include "xf86_OSproc.h"
 #include "xf86Pci.h"
-#include "xf86PciInfo.h"
 #include "xaa.h"
 #include "xaalocal.h"
 #include "ct_driver.h"
@@ -80,7 +79,7 @@ DGAFunctionRec CHIPS_HiQVDGAFuncs = {
 Bool
 CHIPSDGAInit(ScreenPtr pScreen)
 {   
-   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    CHIPSPtr cPtr = CHIPSPTR(pScrn);
    DGAModePtr modes = NULL, newmodes = NULL, currentMode;
    DisplayModePtr pMode, firstMode;
@@ -198,21 +197,21 @@ CHIPS_SetMode(
 	/* put the ScreenParameters back */
        if (cPtr->DGAactive) {
            pScrn->displayWidth = OldDisplayWidth[index];
-	   pScrn->EnterVT(pScrn->scrnIndex,0);
+	   pScrn->EnterVT(VT_FUNC_ARGS);
 
 	   cPtr->DGAactive = FALSE;
        }
    } else {
 	if(!cPtr->DGAactive) {  /* save the old parameters */
 	    OldDisplayWidth[index] = pScrn->displayWidth;
-	    pScrn->LeaveVT(pScrn->scrnIndex,0);
+	    pScrn->LeaveVT(VT_FUNC_ARGS);
 	    cPtr->DGAactive = TRUE;
 	}
 
 	pScrn->displayWidth = pMode->bytesPerScanline / 
 			      (pMode->bitsPerPixel >> 3);
 
-        CHIPSSwitchMode(index, pMode->mode, 0);
+        CHIPSSwitchMode(SWITCH_MODE_ARGS(pScrn, pMode->mode));
    }
    
    return TRUE;
@@ -243,7 +242,7 @@ CHIPS_SetViewport(
 	while (!((hwp->readST01(hwp)) & 0x08)){};
     }
 
-    CHIPSAdjustFrame(pScrn->pScreen->myNum, x, y, flags);
+    CHIPSAdjustFrame(ADJUST_FRAME_ARGS(pScrn, x, y));
     cPtr->DGAViewportStatus = 0;  /* CHIPSAdjustFrame loops until finished */
 }
 
diff --git a/src/ct_driver.c b/src/ct_driver.c
index 6624b79..01cff63 100644
--- a/src/ct_driver.c
+++ b/src/ct_driver.c
@@ -79,9 +79,6 @@
 /* Everything using inb/outb, etc needs "compiler.h" */
 #include "compiler.h"
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
@@ -146,13 +143,12 @@ static Bool     CHIPSPciProbe(DriverPtr drv, int entity_num,
 static Bool     CHIPSProbe(DriverPtr drv, int flags);
 #endif
 static Bool     CHIPSPreInit(ScrnInfoPtr pScrn, int flags);
-static Bool     CHIPSScreenInit(int Index, ScreenPtr pScreen, int argc,
-                                  char **argv);
-static Bool     CHIPSEnterVT(int scrnIndex, int flags);
-static void     CHIPSLeaveVT(int scrnIndex, int flags);
-static Bool     CHIPSCloseScreen(int scrnIndex, ScreenPtr pScreen);
-static void     CHIPSFreeScreen(int scrnIndex, int flags);
-static ModeStatus CHIPSValidMode(int scrnIndex, DisplayModePtr mode,
+static Bool     CHIPSScreenInit(SCREEN_INIT_ARGS_DECL);
+static Bool     CHIPSEnterVT(VT_FUNC_ARGS_DECL);
+static void     CHIPSLeaveVT(VT_FUNC_ARGS_DECL);
+static Bool     CHIPSCloseScreen(CLOSE_SCREEN_ARGS_DECL);
+static void     CHIPSFreeScreen(FREE_SCREEN_ARGS_DECL);
+static ModeStatus CHIPSValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode,
                                  Bool verbose, int flags);
 static Bool	CHIPSSaveScreen(ScreenPtr pScreen, int mode);
 
@@ -202,7 +198,7 @@ static void     chipsLoadPalette(ScrnInfoPtr pScrn, int numColors,
 static void     chipsLoadPalette16(ScrnInfoPtr pScrn, int numColors,
 				int *indices, LOCO *colors, VisualPtr pVisual);
 static void chipsSetPanelType(CHIPSPtr cPtr);
-static void chipsBlockHandler(int, pointer, pointer, pointer);
+static void chipsBlockHandler(BLOCKHANDLER_ARGS_DECL);
 
 /*
  * This is intentionally screen-independent.  It indicates the binding
@@ -481,6 +477,19 @@ static DisplayModeRec ChipsNTSCMode = {
 
 #ifdef XSERVER_LIBPCIACCESS
 
+#ifndef _XF86_PCIINFO_H
+#define PCI_VENDOR_CHIPSTECH		0x102C
+/* Chips & Tech */
+#define PCI_CHIP_65545			0x00D8
+#define PCI_CHIP_65548			0x00DC
+#define PCI_CHIP_65550			0x00E0
+#define PCI_CHIP_65554			0x00E4
+#define PCI_CHIP_65555			0x00E5
+#define PCI_CHIP_68554			0x00F4
+#define PCI_CHIP_69000			0x00C0
+#define PCI_CHIP_69030			0x0C30
+#endif
+
 #define CHIPS_DEVICE_MATCH(d, i) \
   { PCI_VENDOR_CHIPSTECH, (d), PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, (i) }
 
@@ -949,7 +958,7 @@ CHIPSProbe(DriverPtr drv, int flags)
 		}
 
 	    }
-	    xfree(usedChips);
+	    free(usedChips);
 	}
     }
 
@@ -981,12 +990,12 @@ CHIPSProbe(DriverPtr drv, int flags)
 		pScrn->ValidMode     = CHIPSValidMode;
 		foundScreen = TRUE;
 	    }
-	    xfree(usedChips);
+	    free(usedChips);
 	}
     }
 #endif
     
-    xfree(devSections);
+    free(devSections);
     return foundScreen;
 }
 #endif
@@ -1345,10 +1354,9 @@ CHIPSPreInit(ScrnInfoPtr pScrn, int flags)
     
     if (cPtr->Flags & ChipsAccelSupport) {
 	if (!xf86LoadSubModule(pScrn, "xaa")) {
-	    vbeFree(cPtr->pVbe);
-	    cPtr->pVbe = NULL;
-	    CHIPSFreeRec(pScrn);
-	    return FALSE;
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Falling back to shadowfb\n");
+	    cPtr->Flags &= ~(ChipsAccelSupport);
+	    cPtr->Flags |= ChipsShadowFB;
 	}
     }
 
@@ -1445,8 +1453,14 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
         return FALSE;
 
     hwp = VGAHWPTR(pScrn);
+    vgaHWSetStdFuncs(hwp);
     vgaHWGetIOBase(hwp);
+#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
     cPtr->PIOBase = hwp->PIOOffset;
+#else
+    cPtr->PIOBase = 0;
+#endif
+
     /*
      * Must allow ensure that storage for the 2nd set of vga registers is
      * allocated for dual channel cards
@@ -1639,55 +1653,15 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
 	}
     }
     
-    if ((s = xf86GetOptValString(cPtr->Options, OPTION_OVERLAY))) {
-	if (!*s || !xf86NameCmp(s, "8,16") || !xf86NameCmp(s, "16,8")) {
-	  if (pScrn->bitsPerPixel == 16) {
-	    if (cPtr->Flags & ChipsLinearSupport) {
-		cPtr->Flags |= ChipsOverlay8plus16;
-		if(!xf86GetOptValInteger(
-			cPtr->Options, OPTION_COLOR_KEY, &(pScrn->colorKey)))
-		    pScrn->colorKey = TRANSPARENCY_KEY;
-		pScrn->overlayFlags = OVERLAY_8_16_DUALFB;
-		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
-			   "PseudoColor overlay enabled.\n");
-		if (!xf86IsOptionSet(cPtr->Options, OPTION_LCD_STRETCH))
-		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-			   "                             - Forcing option \"Stretch\" \"ON\".\n");
-		if (!xf86IsOptionSet(cPtr->Options, OPTION_LCD_CENTER))
-		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-			   "                             - Forcing option \"LcdCenter\" \"OFF\".\n");
-		if (cPtr->Flags & ChipsShadowFB) {
-		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		           "                             - Disabling \"Shadow Framebuffer\".\n");
-		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-			   "                               Not support with option \"8Plus16\".\n");
-		    cPtr->Flags &= ~ChipsShadowFB;
-		    cPtr->Rotate = 0;
-		}
-	    } else {
-		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Option \"Overlay\" ignored. Not supported without linear addressing\n");
-	    }
-	  } else {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-		"Option \"Overlay\" is not supported in this configuration\n");
-	  }
-	} else {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-		"\"%s\" is not a valid value for Option \"Overlay\"\n", s); 
-	}
-    }
-
-    if (!(cPtr->Flags & ChipsOverlay8plus16)) {
-	if(xf86GetOptValInteger(cPtr->Options, OPTION_VIDEO_KEY,
-		&(cPtr->videoKey))) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
+    if(xf86GetOptValInteger(cPtr->Options, OPTION_VIDEO_KEY,
+	&(cPtr->videoKey))) {
+         xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
 		cPtr->videoKey);
-	} else {
-	    cPtr->videoKey =  (1 << pScrn->offset.red) | 
+    } else {
+       cPtr->videoKey =  (1 << pScrn->offset.red) | 
 			(1 << pScrn->offset.green) |
 			(((pScrn->mask.blue >> pScrn->offset.blue) - 1)
 			<< pScrn->offset.blue); 
-	}
     }
 
     if (cPtr->Flags & ChipsShadowFB) {
@@ -1953,7 +1927,7 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
 	if (!ddc_done)
 	    if (xf86LoadSubModule(pScrn, "i2c")) {
 		if (chips_i2cInit(pScrn)) {
-		    if ((pMon = xf86PrintEDID(xf86DoEDID_DDC2(pScrn->scrnIndex,
+		    if ((pMon = xf86PrintEDID(xf86DoEDID_DDC2(XF86_SCRN_ARG(pScrn),
 						      cPtr->I2C))) != NULL)
 		       ddc_done = TRUE;
 		       xf86SetDDCproperties(pScrn,pMon);
@@ -2335,28 +2309,16 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
     /* and 32bits on the others. Thus multiply by a suitable factor      */  
     if (cPtr->Flags & Chips64BitMemory) {
 	if (cPtr->FrameBufferSize && (cPtr->PanelType & ChipsLCD))
-	    if (cPtr->Flags & ChipsOverlay8plus16 )
-		cPtr->MaxClock = min(cPtr->MaxClock, MemClk->Clk * 8 * 0.7 / 4);
-	    else
 		cPtr->MaxClock = min(cPtr->MaxClock,
 			     MemClk->Clk * 8 * 0.7 / (bytesPerPixel + 1));
 	else
-	    if (cPtr->Flags & ChipsOverlay8plus16)
-		cPtr->MaxClock = min(cPtr->MaxClock, MemClk->Clk * 8 * 0.7 / 3);
-	    else
 		cPtr->MaxClock = min(cPtr->MaxClock, 
 			     MemClk->Clk * 8 * 0.7 / bytesPerPixel);
     } else {
 	if (cPtr->FrameBufferSize && (cPtr->PanelType & ChipsLCD))
-	    if (cPtr->Flags & ChipsOverlay8plus16 )
-		cPtr->MaxClock = min(cPtr->MaxClock, MemClk->Clk * 4 * 0.7 / 4);
-	    else
 		cPtr->MaxClock = min(cPtr->MaxClock,
 			     MemClk->Clk * 4 * 0.7 / (bytesPerPixel + 1));
 	else
-	    if (cPtr->Flags & ChipsOverlay8plus16)
-		cPtr->MaxClock = min(cPtr->MaxClock, MemClk->Clk * 4 * 0.7 / 3);
-	    else
 		cPtr->MaxClock = min(cPtr->MaxClock, 
 			     MemClk->Clk * 4 * 0.7 / bytesPerPixel);
     }
@@ -3722,9 +3684,9 @@ chipsPreInit655xx(ScrnInfoPtr pScrn, int flags)
 
 /* Mandatory */
 static Bool
-CHIPSEnterVT(int scrnIndex, int flags)
+CHIPSEnterVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSEntPtr cPtrEnt;
 
@@ -3736,8 +3698,7 @@ CHIPSEnterVT(int scrnIndex, int flags)
     /* Should we re-save the text mode on each VT enter? */
     if(!chipsModeInit(pScrn, pScrn->currentMode))
       return FALSE;
-    if ((!(cPtr->Flags & ChipsOverlay8plus16)) 
-	&& (cPtr->Flags & ChipsVideoSupport)
+    if ((cPtr->Flags & ChipsVideoSupport)
 	&& (cPtr->Flags & ChipsLinearSupport)) 
         CHIPSResetVideo(pScrn); 
 
@@ -3745,16 +3706,16 @@ CHIPSEnterVT(int scrnIndex, int flags)
     chipsHWCursorOn(cPtr, pScrn);
     /* cursor settle delay */
     usleep(50000);
-    CHIPSAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);    
+    CHIPSAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
     usleep(50000);
     return TRUE;
 }
 
 /* Mandatory */
 static void
-CHIPSLeaveVT(int scrnIndex, int flags)
+CHIPSLeaveVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSACLPtr cAcl = CHIPSACLPTR(pScrn);
     CHIPSEntPtr cPtrEnt;
@@ -3788,8 +3749,7 @@ chipsLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
     int i, index, shift ;
     CHIPSEntPtr cPtrEnt;    
 
-    shift = ((pScrn->depth == 15) && 
-	     (!(cPtr->Flags & ChipsOverlay8plus16))) ? 3 : 0;
+    shift = (pScrn->depth == 15) ? 3 : 0;
 
     if (cPtr->UseDualChannel) {
         cPtrEnt = xf86GetEntityPrivate(pScrn->entityList[0],
@@ -3895,23 +3855,11 @@ chipsLoadPalette16(ScrnInfoPtr pScrn, int numColors, int *indices,
     hwp->disablePalette(hwp);
 }
 
-static Bool
-cfb8_16ScreenInit(ScreenPtr pScreen, pointer pbits16, pointer pbits8,
-                  int xsize, int ysize, int dpix, int dpiy,
-                  int width16, int width8)
-{
-    return
-        (fbOverlaySetupScreen(pScreen, pbits16, pbits8, xsize, ysize,
-                              dpix, dpiy, width16, width8, 16, 8) &&
-         fbOverlayFinishScreenInit(pScreen, pbits16, pbits8, xsize, ysize,
-                                   dpix, dpiy, width16, width8, 16, 8, 16, 8));
-}
-
 /* Mandatory */
 static Bool
-CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
+CHIPSScreenInit(SCREEN_INIT_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     vgaHWPtr hwp;
     CHIPSPtr cPtr;
     CHIPSACLPtr cAcl;
@@ -3947,22 +3895,6 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     if (!chipsMapMem(pScrn))
 	return FALSE;
 
-    /* Setup a pointer to the overlay if needed */
-    if (cPtr->Flags & ChipsOverlay8plus16) {
-	cPtr->FbOffset16 = pScrn->displayWidth * pScrn->virtualY;
-	cPtr->FbSize16 =  (pScrn->displayWidth << 1) * pScrn->virtualY;
-	if (cPtr->FbSize16 > (cPtr->FbMapSize - cPtr->FrameBufferSize)) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		   "Too little memory for overlay. Disabling.\n");
-	    cPtr->Flags &= ~ChipsOverlay8plus16;
-	}
-	if ((pScrn->displayWidth > 1024) || (pScrn->virtualY > 1024)) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		   "Max overlay Width/Height 1024 pixels. Disabling.\n");
-	    cPtr->Flags &= ~ChipsOverlay8plus16;
-	}
-    }
-
     /* Setup the MMIO register access functions if need */
     if (cPtr->UseFullMMIO && cPtr->MMIOBaseVGA) {
 	CHIPSSetMmioExtFuncs(cPtr);
@@ -4015,7 +3947,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     if (!chipsModeInit(pScrn,pScrn->currentMode))
 	return FALSE;
     CHIPSSaveScreen(pScreen,SCREEN_SAVER_ON);
-    CHIPSAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+    CHIPSAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
     
     /*
      * The next step is to setup the screen's visuals, and initialise the
@@ -4035,18 +3967,10 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     miClearVisualTypes();
 
     /* Setup the visuals we support. */
-    if ((pScrn->bitsPerPixel == 16) && (cPtr->Flags & ChipsOverlay8plus16)){
-	if (!miSetVisualTypes(8, PseudoColorMask | GrayScaleMask,
-			      pScrn->rgbBits, PseudoColor))
-		return FALSE;
-	if (!miSetVisualTypes(16, TrueColorMask, pScrn->rgbBits, TrueColor))
-		return FALSE;
-    } else {
-      if (!miSetVisualTypes(pScrn->depth,
+    if (!miSetVisualTypes(pScrn->depth,
 			    miGetDefaultVisualMask(pScrn->depth),
 			    pScrn->rgbBits, pScrn->defaultVisual))
-	return FALSE;
-    }
+        return FALSE;
     miSetPixmapDepths ();
 
     /*
@@ -4090,13 +4014,6 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	break;
 #endif
     case 16:
-      if (cPtr->Flags & ChipsOverlay8plus16) {
-	  ret = cfb8_16ScreenInit(pScreen, (unsigned char *)FBStart + 
-				  cPtr->FbOffset16, FBStart, width, 
-				  height, pScrn->xDpi, pScrn->yDpi,
-				  displayWidth, displayWidth);
-	  break;
-      }
     default:
 	ret = fbScreenInit(pScreen, FBStart,
  		        width,height,
@@ -4223,7 +4140,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	}
 	if (!miInitializeBanking(pScreen, pScrn->virtualX, pScrn->virtualY,
 				 pScrn->displayWidth, pBankInfo)) {
-	    xfree(pBankInfo);
+	    free(pBankInfo);
 	    pBankInfo = NULL;
 	    return FALSE;
 	}
@@ -4244,9 +4161,6 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	if (pScrn->bitsPerPixel < 8)
 	    freespace = allocatebase - pScrn->displayWidth * 
 		    pScrn->virtualY / 2;
-	else if ((pScrn->bitsPerPixel == 16) && (cPtr->Flags & ChipsOverlay8plus16))
-	    freespace = allocatebase - pScrn->displayWidth * 
-		    pScrn->virtualY - cPtr->FbSize16;
 	else	
 	    freespace = allocatebase - pScrn->displayWidth * 
 		    pScrn->virtualY * (pScrn->bitsPerPixel >> 3);
@@ -4257,7 +4171,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	} else
 	    currentaddr = allocatebase;
 	if (serverGeneration == 1)
-	    xf86DrvMsg(scrnIndex, X_PROBED,
+	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 		   "%d bytes off-screen memory available\n", freespace);
 
 	/* 
@@ -4282,7 +4196,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 		cAcl->CursorAddress = currentaddr;
 	    }
 	    if (cAcl->CursorAddress == -1)
-		xf86DrvMsg(scrnIndex, X_ERROR,
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Too little space for H/W cursor.\n");
 	}
     
@@ -4342,7 +4256,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	    cAcl->CacheEnd = currentaddr;
 
 	    if (cAcl->CacheStart >= cAcl->CacheEnd) {
-		xf86DrvMsg(scrnIndex, X_ERROR,
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Too little space for pixmap cache.\n");
 		cAcl->CacheStart = 0;
 		cAcl->CacheEnd = 0;
@@ -4369,9 +4283,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	    AvailFBArea.y2 = cAcl->CacheEnd /
 		(pScrn->displayWidth * (pScrn->bitsPerPixel >> 3));
 
-	    if (!(cPtr->Flags & ChipsOverlay8plus16)) {     
-		xf86InitFBManager(pScreen, &AvailFBArea); 
-	    }
+	    xf86InitFBManager(pScreen, &AvailFBArea); 
 	}
 	if (cPtr->Flags & ChipsAccelSupport) {
 	    if (IS_HiQV(cPtr)) {
@@ -4395,7 +4307,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	if ((cAcl->UseHWCursor) && (cAcl->CursorAddress != -1)) {
 	    /* HW cursor functions */
 	    if (!CHIPSCursorInit(pScreen)) {
-		xf86DrvMsg(scrnIndex, X_ERROR,
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Hardware cursor initialization failed\n");
 		return FALSE;
 	    }
@@ -4425,16 +4337,10 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     if (!miCreateDefColormap(pScreen))
 	return FALSE;
     
-    if ((cPtr->Flags & ChipsOverlay8plus16) && (pScrn->bitsPerPixel == 16)) {
-	if(!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits, chipsLoadPalette,
-		NULL, CMAP_RELOAD_ON_MODE_SWITCH))
-	    return FALSE;
-    } else {
-	if(!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits,
+    if(!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits,
 		(pScrn->depth == 16 ? chipsLoadPalette16 : chipsLoadPalette),
 		NULL, CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR))
-	    return FALSE;
-    }
+	return FALSE;
     
 #ifndef XSERVER_LIBPCIACCESS
     racflag = RAC_COLORMAP;
@@ -4448,8 +4354,7 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	xf86SetSilkenMouse(pScreen);
 #endif
 
-	if ((!(cPtr->Flags & ChipsOverlay8plus16)) 
-	    && (cPtr->Flags & ChipsVideoSupport)
+	if ((cPtr->Flags & ChipsVideoSupport)
 	    && (cPtr->Flags & ChipsLinearSupport)) {
 	    CHIPSInitVideo(pScreen);
     }
@@ -4475,9 +4380,9 @@ CHIPSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
 /* Mandatory */
 Bool
-CHIPSSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
+CHIPSSwitchMode(SWITCH_MODE_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSEntPtr cPtrEnt;
 
@@ -4490,14 +4395,14 @@ CHIPSSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
 	DUALREOPEN;
     }
 
-    return chipsModeInit(xf86Screens[scrnIndex], mode);
+    return chipsModeInit(pScrn, mode);
 }
 
 /* Mandatory */
 void
-CHIPSAdjustFrame(int scrnIndex, int x, int y, int flags)
+CHIPSAdjustFrame(ADJUST_FRAME_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSEntPtr cPtrEnt;
 
@@ -4522,10 +4427,7 @@ CHIPSAdjustFrame(int scrnIndex, int x, int y, int flags)
 	Base >>= 3;
 	break;
     case 16:
-	if (!(cPtr->Flags & ChipsOverlay8plus16))
-	   Base >>= 1;
-	else
-	   Base >>= 2;
+	Base >>= 1;
 	break;
     case 24:
 	if (!IS_HiQV(cPtr))
@@ -4581,21 +4483,13 @@ CHIPSAdjustFrame(int scrnIndex, int x, int y, int flags)
 	cPtr->writeMSS(cPtr, hwp, MSS);
     }
 
-    if (cPtr->Flags & ChipsOverlay8plus16) {
-	Base = (Base << 3) & ~(unsigned long)0xF;
-
-	cPtr->writeMR(cPtr, 0x22, (cPtr->FbOffset16 + Base) & 0xF8);
-	cPtr->writeMR(cPtr, 0x23, ((cPtr->FbOffset16 + Base) >> 8) & 0xFF);
-	cPtr->writeMR(cPtr, 0x24, ((cPtr->FbOffset16 + Base) >> 16) & 0xFF);
-    }
-
 }
 
 /* Mandatory */
 static Bool
-CHIPSCloseScreen(int scrnIndex, ScreenPtr pScreen)
+CHIPSCloseScreen(CLOSE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     CHIPSEntPtr cPtrEnt;    
 
@@ -4633,32 +4527,26 @@ CHIPSCloseScreen(int scrnIndex, ScreenPtr pScreen)
 
     pScreen->CloseScreen = cPtr->CloseScreen; /*§§§*/
     xf86ClearPrimInitDone(pScrn->entityList[0]);
-    return (*pScreen->CloseScreen)(scrnIndex, pScreen);/*§§§*/
+    return (*pScreen->CloseScreen)(CLOSE_SCREEN_ARGS);/*§§§*/
 }
 
 /* Optional */
 static void
-CHIPSFreeScreen(int scrnIndex, int flags)
+CHIPSFreeScreen(FREE_SCREEN_ARGS_DECL)
 {
+    SCRN_INFO_PTR(arg);
     if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
-	vgaHWFreeHWRec(xf86Screens[scrnIndex]);
-    CHIPSFreeRec(xf86Screens[scrnIndex]);
+	vgaHWFreeHWRec(pScrn);
+    CHIPSFreeRec(pScrn);
 }
 
 /* Optional */
 static ModeStatus
-CHIPSValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
+CHIPSValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
 
-    if (flags & MODECHECK_FINAL) {
-    /* Don't subtract FrambufferSize here as it should be subtracted already */
-    if ((cPtr->Flags & ChipsOverlay8plus16) 
-      && ((pScrn->videoRam<<10) - pScrn->displayWidth * 3 * pScrn->virtualY 
-	  < 0))
-	return MODE_MEM;
-    }
     /* The tests here need to be expanded */
     if ((mode->Flags & V_INTERLACE) && (cPtr->PanelType & ChipsLCD))
 	return MODE_NO_INTERLACE;
@@ -4781,7 +4669,7 @@ CHIPSSaveScreen(ScreenPtr pScreen, int mode)
     unblank = xf86IsUnblank(mode);
 
     if (pScreen != NULL)
-	pScrn = xf86Screens[pScreen->myNum];
+	pScrn = xf86ScreenToScrn(pScreen);
 
     if (unblank)
 	SetTimeSinceLastInputEvent();
@@ -5544,12 +5432,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
     } else {
 	ChipsStd->Attribute[0x10] = 0x01;   /* mode */
     }
-    if ((pScrn->bitsPerPixel == 16) && (cPtr->Flags & ChipsOverlay8plus16)) {
-	/* Make sure that the overlay isn't visible in the overscan region */
-	if (ChipsStd->Attribute[0x11] == pScrn->colorKey)
-	    ChipsStd->Attribute[0x11] = pScrn->colorKey - 1;
-    } else
-	ChipsStd->Attribute[0x11] = 0x00;   /* overscan (border) color */
+    ChipsStd->Attribute[0x11] = 0x00;   /* overscan (border) color */
     ChipsStd->Attribute[0x12] = 0x0F;   /* enable all color planes */
     ChipsStd->Attribute[0x13] = 0x00;   /* horiz pixel panning 0 */
 
@@ -5558,8 +5441,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
     /* set virtual screen width */
     tmp = pScrn->displayWidth >> 3;
     if (pScrn->bitsPerPixel == 16) {
-	if (!(cPtr->Flags & ChipsOverlay8plus16))
-	    tmp <<= 1;		       /* double the width of the buffer */
+	tmp <<= 1;		       /* double the width of the buffer */
     } else if (pScrn->bitsPerPixel == 24) {
 	tmp += tmp << 1;
     } else if (pScrn->bitsPerPixel == 32) {
@@ -5688,8 +5570,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
 
     /* centering/stretching */
     if (!xf86ReturnOptValBool(cPtr->Options, OPTION_SUSPEND_HACK, FALSE)) {
-	if (!xf86ReturnOptValBool(cPtr->Options, OPTION_LCD_STRETCH, FALSE) ||
-	(cPtr->Flags & ChipsOverlay8plus16)) {
+	if (!xf86ReturnOptValBool(cPtr->Options, OPTION_LCD_STRETCH, FALSE)) {
 	    ChipsNew->FR[0x40] &= 0xDF;    /* Disable Horizontal stretching */
 	    ChipsNew->FR[0x48] &= 0xFB;    /* Disable vertical stretching */
 	    ChipsNew->XR[0xA0] = 0x10;     /* Disable cursor stretching */
@@ -5709,8 +5590,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	}
     }
 
-    if ((xf86ReturnOptValBool(cPtr->Options, OPTION_LCD_CENTER, TRUE))
-		|| (cPtr->Flags & ChipsOverlay8plus16)) {
+    if (xf86ReturnOptValBool(cPtr->Options, OPTION_LCD_CENTER, TRUE)) {
 	ChipsNew->FR[0x40] |= 0x3;    /* Enable Horizontal centering */
 	ChipsNew->FR[0x48] |= 0x3;    /* Enable Vertical centering */
     } else {
@@ -5723,8 +5603,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	ChipsNew->XR[0x82] |=0x02;
 
     /* software mode flag */
-    ChipsNew->XR[0xE2] = chipsVideoMode(((cPtr->Flags & ChipsOverlay8plus16) ?
-	8 : pScrn->depth), (cPtr->PanelType & ChipsLCD) ?
+    ChipsNew->XR[0xE2] = chipsVideoMode((pScrn->depth), (cPtr->PanelType & ChipsLCD) ?
 	min(mode->CrtcHDisplay, cPtr->PanelSize.HDisplay) :
 	mode->CrtcHDisplay, mode->CrtcVDisplay);
 #ifdef DEBUG
@@ -5762,7 +5641,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
     	}
     }	    
     /* bpp depend */
-    if ((pScrn->bitsPerPixel == 16) && (!(cPtr->Flags & ChipsOverlay8plus16))) {
+    if (pScrn->bitsPerPixel == 16) {
 	ChipsNew->XR[0x81] = (ChipsNew->XR[0x81] & 0xF0) | 0x4;
 	if (cPtr->Flags & ChipsGammaSupport)
 	    ChipsNew->XR[0x82] |= 0x0C;
@@ -5915,60 +5794,7 @@ chipsModeInitHiQV(ScrnInfoPtr pScrn, DisplayModePtr mode)
     /* Turn off multimedia by default as it degrades performance */
     ChipsNew->XR[0xD0] &= 0x0f;	 
     
-    /* Setup the video/overlay */
-    if (cPtr->Flags & ChipsOverlay8plus16) {
-	ChipsNew->XR[0xD0] |= 0x10;	/* Force the Multimedia engine on */
-#ifdef SAR04
-	ChipsNew->XR[0x4F] = 0x2A;	/* SAR04 >352 pixel overlay width */
-#endif
-	ChipsNew->MR[0x1E] &= 0xE0;	/* Set Zoom and Direction */
-	if ((!(cPtr->PanelType & ChipsLCD)) && (mode->Flags & V_INTERLACE))
-	    ChipsNew->MR[0x1E] |= 0x10;	/* Interlace */
-	ChipsNew->MR[0x1F] &= 0x14;	/* Mask reserved bits */
-	ChipsNew->MR[0x1F] |= 0x08;	/* RGB 16bpp */
-	if (pScrn->weight.green == 5)
-	    ChipsNew->MR[0x1F] |= 0x01;	/* RGB 15bpp */
-
-	ChipsNew->MR[0x20] &= 0x03;	/* Mask reserved bits */
-	ChipsNew->MR[0x20] |= 0x80;	/* Auto Centre, Use mem ptr1 */
-	ChipsNew->MR[0x22] = cPtr->FbOffset16 & 0xF8;	/* Setup Pointer 1 */
-	ChipsNew->MR[0x23] = (cPtr->FbOffset16 >> 8) & 0xFF;
-	ChipsNew->MR[0x24] = (cPtr->FbOffset16 >> 16) & 0xFF;
-	ChipsNew->MR[0x25] = cPtr->FbOffset16 & 0xF8;	/* Setup Pointer 2 */
-	ChipsNew->MR[0x26] = (cPtr->FbOffset16 >> 8) & 0xFF;
-	ChipsNew->MR[0x27] = (cPtr->FbOffset16 >> 16) & 0xFF;
-	ChipsNew->MR[0x28] = (pScrn->displayWidth >> 2) - 1; /* Width */ 
-	ChipsNew->MR[0x34] = (pScrn->displayWidth >> 2) - 1;
-
-	/* Left Edge of Overlay */
-	ChipsNew->MR[0x2A] = cPtr->OverlaySkewX;
-	ChipsNew->MR[0x2B] &= 0xF8;	/* Mask reserved bits */
-	ChipsNew->MR[0x2B] |= ((cPtr->OverlaySkewX >> 8) & 0x7);
-	/* Right Edge of Overlay */
-	ChipsNew->MR[0x2C] = (cPtr->OverlaySkewX + pScrn->displayWidth - 
-							1) & 0xFF;
-	ChipsNew->MR[0x2D] &= 0xF8;	/* Mask reserved bits */
-	ChipsNew->MR[0x2D] |= ((cPtr->OverlaySkewX + pScrn->displayWidth -
-							1) >> 8) & 0x07;
-	/* Top Edge of Overlay */
-	ChipsNew->MR[0x2E] = cPtr->OverlaySkewY;
-	ChipsNew->MR[0x2F] &= 0xF8;
-	ChipsNew->MR[0x2F] |= ((cPtr->OverlaySkewY >> 8) & 0x7);
-	/* Bottom Edge of Overlay*/
-	ChipsNew->MR[0x30] = (cPtr->OverlaySkewY + pScrn->virtualY - 1 )& 0xFF;
-	ChipsNew->MR[0x31] &= 0xF8;	/* Mask reserved bits */
-	ChipsNew->MR[0x31] |= ((cPtr->OverlaySkewY + pScrn->virtualY - 
-							1 ) >> 8) & 0x07;
-
-	ChipsNew->MR[0x3C] &= 0x18;	/* Mask reserved bits */
-	ChipsNew->MR[0x3C] |= 0x07;	/* Enable keyed overlay window */
-	ChipsNew->MR[0x3D] = 0x00;
-	ChipsNew->MR[0x3E] = 0x00;
-	ChipsNew->MR[0x3F] = pScrn->colorKey; /* 8bpp transparency key */
-	ChipsNew->MR[0x40] = 0xFF;
-	ChipsNew->MR[0x41] = 0xFF;
-	ChipsNew->MR[0x42] = 0x00;
-    } else if (cPtr->Flags & ChipsVideoSupport) {
+    if (cPtr->Flags & ChipsVideoSupport) {
 #if 0   /* if we do this even though video isn't playing we kill performance */
 	ChipsNew->XR[0xD0] |= 0x10;	/* Force the Multimedia engine on */
 #endif
@@ -6877,8 +6703,7 @@ chipsRestoreExtendedRegs(ScrnInfoPtr pScrn, CHIPSRegPtr Regs)
 	}
 
 	/* Set SAR04 multimedia register correctly */
-	if ((cPtr->Flags & ChipsOverlay8plus16)
-	    || (cPtr->Flags & ChipsVideoSupport)) {
+	if ((cPtr->Flags & ChipsVideoSupport)) {
 #ifdef SAR04
 	    cPtr->writeXR(cPtr, 0x4E, 0x04);
 	    if (cPtr->readXR(cPtr, 0x4F) != Regs->XR[0x4F])
@@ -7662,18 +7487,14 @@ chipsSetPanelType(CHIPSPtr cPtr)
 }
 
 static void
-chipsBlockHandler (
-    int i,
-    pointer     blockData,
-    pointer     pTimeout,
-    pointer     pReadmask
-){
-    ScreenPtr   pScreen = screenInfo.screens[i];
-    ScrnInfoPtr pScrn = xf86Screens[i];
+chipsBlockHandler (BLOCKHANDLER_ARGS_DECL)
+{
+    SCREEN_PTR(arg);
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr    cPtr = CHIPSPTR(pScrn);
     
     pScreen->BlockHandler = cPtr->BlockHandler;
-    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
+    (*pScreen->BlockHandler) (BLOCKHANDLER_ARGS);
     pScreen->BlockHandler = chipsBlockHandler;
 
     if(cPtr->VideoTimerCallback) {
diff --git a/src/ct_driver.h b/src/ct_driver.h
index d8ce228..cbb7da3 100644
--- a/src/ct_driver.h
+++ b/src/ct_driver.h
@@ -38,6 +38,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "compat-api.h"
+
 /* Supported chipsets */
 typedef enum {
     CHIPS_CT65520,
@@ -114,7 +116,6 @@ typedef struct {
 /* Options flags for the C&T chipsets */
 #define ChipsHWCursor		0x00001000
 #define ChipsShadowFB		0x00002000
-#define ChipsOverlay8plus16	0x00004000
 #define ChipsUseNewFB		0x00008000
 
 /* Architecture type flags */
@@ -272,11 +273,13 @@ typedef struct {
 
 typedef struct _CHIPSRec {
     pciVideoPtr		PciInfo;
+#ifndef XSERVER_LIBPCIACCESS
     PCITAG		PciTag;
+#endif
     int			Chipset;
     EntityInfoPtr       pEnt;
-    IOADDRESS		PIOBase;
-    CARD32		IOAddress;
+    unsigned long	PIOBase;
+    unsigned long	IOAddress;
     unsigned long	FbAddress;
     unsigned int	IOBase;
     unsigned char *	FbBase;
@@ -288,7 +291,7 @@ typedef struct _CHIPSRec {
     unsigned char *	ShadowPtr;
     int			ShadowPitch;
     int                 Rotate;
-    void		(*PointerMoved)(int index, int x, int y);
+    void		(*PointerMoved)(SCRN_ARG_TYPE arg, int x, int y);
     int                 FbOffset16;
     int                 FbSize16;  
     OptionInfoPtr	Options;
@@ -381,8 +384,8 @@ extern unsigned int ChipsReg32HiQV[];
 
 /* Prototypes */
 
-void CHIPSAdjustFrame(int scrnIndex, int x, int y, int flags);
-Bool CHIPSSwitchMode(int scrnIndex, DisplayModePtr mode, int flags);
+void CHIPSAdjustFrame(ADJUST_FRAME_ARGS_DECL);
+Bool CHIPSSwitchMode(SWITCH_MODE_ARGS_DECL);
 
 /* video */
 void CHIPSInitVideo(ScreenPtr pScreen);
@@ -431,7 +434,7 @@ void     chipsRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void     chipsRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void     chipsRefreshArea24(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void     chipsRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
-void     chipsPointerMoved(int index, int x, int y);
+void     chipsPointerMoved(SCRN_ARG_TYPE arg, int x, int y);
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
 # define BE_SWAP_APRETURE(pScrn,cPtr) \
diff --git a/src/ct_regs.c b/src/ct_regs.c
index e9a4c20..4446b33 100644
--- a/src/ct_regs.c
+++ b/src/ct_regs.c
@@ -58,9 +58,6 @@
 /* Everything using inb/outb, etc needs "compiler.h" */
 #include "compiler.h"
 
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
 /* Drivers that need to access the PCI config space directly need this */
 #include "xf86Pci.h"
 
diff --git a/src/ct_shadow.c b/src/ct_shadow.c
index 896eac3..66b0ba7 100644
--- a/src/ct_shadow.c
+++ b/src/ct_shadow.c
@@ -5,7 +5,6 @@
 
 #include "xf86.h"
 #include "xf86_OSproc.h"
-#include "xf86PciInfo.h"
 #include "xf86Pci.h"
 #include "shadowfb.h"
 #include "servermd.h"
@@ -39,9 +38,9 @@ chipsRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 } 
 
 void
-chipsPointerMoved(int index, int x, int y)
+chipsPointerMoved(SCRN_ARG_TYPE arg, int x, int y)
 {
-    ScrnInfoPtr pScrn = xf86Screens[index];
+    SCRN_INFO_PTR(arg);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     int newX, newY;
     
@@ -53,7 +52,7 @@ chipsPointerMoved(int index, int x, int y)
 	newY = pScrn->pScreen->width - x - 1;
     }
 
-    (*cPtr->PointerMoved)(index, newX, newY);
+    (*cPtr->PointerMoved)(arg, newX, newY);
 }
 
 void
diff --git a/src/ct_video.c b/src/ct_video.c
index a68acb9..248d2cf 100644
--- a/src/ct_video.c
+++ b/src/ct_video.c
@@ -6,7 +6,6 @@
 #include "xf86.h"
 #include "xf86_OSproc.h"
 #include "compiler.h"
-#include "xf86PciInfo.h"
 #include "xf86Pci.h"
 #include "xf86fbman.h"
 #include "regionstr.h"
@@ -50,14 +49,13 @@ static Atom xvColorKey;
 void 
 CHIPSInitVideo(ScreenPtr pScreen)
 {
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
     XF86VideoAdaptorPtr newAdaptor = NULL;
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     int num_adaptors;
 	
-    if (!(cPtr->Flags & ChipsOverlay8plus16) &&
-       (cPtr->Flags & ChipsVideoSupport)) {
+    if ((cPtr->Flags & ChipsVideoSupport)) {
 	newAdaptor = CHIPSSetupImageVideo(pScreen);
 	CHIPSInitOffscreenImages(pScreen);
     }
@@ -230,7 +228,7 @@ CHIPSResetVideo(ScrnInfoPtr pScrn)
 static XF86VideoAdaptorPtr 
 CHIPSSetupImageVideo(ScreenPtr pScreen)
 {
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
     CHIPSPtr cPtr = CHIPSPTR(pScrn);
     XF86VideoAdaptorPtr adapt;
     CHIPSPortPrivPtr pPriv;
@@ -464,7 +462,7 @@ CHIPSAllocateMemory(
 	xf86FreeOffscreenLinear(linear);
    }
 
-   pScreen = screenInfo.screens[pScrn->scrnIndex];
+   pScreen = xf86ScrnToScreen(pScrn);
 
    new_linear = xf86AllocateOffscreenLinear(pScreen, size, 8, 
    						NULL, NULL, NULL);
diff --git a/util/dRegs.c b/util/dRegs.c
index b7edc8f..0d2f0cb 100644
--- a/util/dRegs.c
+++ b/util/dRegs.c
@@ -1,63 +1,8 @@
-
-
-
-
-
-
-#ifdef __NetBSD__
-#  include <sys/types.h>
-#  include <machine/pio.h>
-#  include <machine/sysarch.h>
-#else
-#  if defined(SVR4) && defined(i386)
-#    include <sys/types.h>
-#    ifdef NCR
-       /* broken NCR <sys/sysi86.h> */
-#      define __STDC
-#      include <sys/sysi86.h>
-#      undef __STDC
-#    else
-#      include <sys/sysi86.h>
-#    endif
-#    ifdef SVR4
-#      if !defined(sun)
-#        include <sys/seg.h>
-#      endif
-#    endif
-#    include <sys/v86.h>
-#    if defined(sun)
-#      include <sys/psw.h>
-#    endif
-#  endif
-#  include "AsmMacros.h"
-#endif /* NetBSD */
-
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 
-#ifdef __NetBSD__
-#  define SET_IOPL() i386_iopl(3)
-#  define RESET_IOPL() i386_iopl(0)
-#else
-#  if defined(SVR4) && defined(i386)
-#    ifndef SI86IOPL
-#      define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
-#      define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
-#    else
-#      define SET_IOPL() sysi86(SI86IOPL,3)
-#      define RESET_IOPL() sysi86(SI86IOPL,0)
-#    endif
-#  else
-#    ifdef linux
-#      define SET_IOPL() iopl(3)
-#      define RESET_IOPL() iopl(0)
-#    else
-#      define SET_IOPL() (void)0
-#      define RESET_IOPL() (void)0
-#    endif
-#  endif
-#endif
+#include "iopl.h"
 
 int main(void)
 {
diff --git a/util/iopl.h b/util/iopl.h
new file mode 100644
index 0000000..e08207c
--- /dev/null
+++ b/util/iopl.h
@@ -0,0 +1,60 @@
+#ifdef __NetBSD__
+#  include <sys/types.h>
+#  include <machine/pio.h>
+#  include <machine/sysarch.h>
+#else
+#  if defined(__linux__)
+/* Can't because <sys/iopl.h> provides conflicting inb, outb, etc
+ * #    include <sys/io.h>
+ */
+int iopl(int level);
+#  endif
+#  if defined(SVR4) && defined(i386)
+#    include <sys/types.h>
+#    ifdef NCR
+       /* broken NCR <sys/sysi86.h> */
+#      define __STDC
+#      include <sys/sysi86.h>
+#      undef __STDC
+#    else
+#      include <sys/sysi86.h>
+#    endif
+#    ifdef SVR4
+#      if !defined(sun)
+#        include <sys/seg.h>
+#      endif
+#    endif
+#    include <sys/v86.h>
+#    if defined(sun)
+#      include <sys/psw.h>
+#    endif
+#  endif
+#  include "AsmMacros.h"
+#endif /* NetBSD */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __NetBSD__
+#  define SET_IOPL() i386_iopl(3)
+#  define RESET_IOPL() i386_iopl(0)
+#else
+#  if defined(SVR4) && defined(i386)
+#    ifndef SI86IOPL
+#      define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
+#      define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
+#    else
+#      define SET_IOPL() sysi86(SI86IOPL,3)
+#      define RESET_IOPL() sysi86(SI86IOPL,0)
+#    endif
+#  else
+#    ifdef linux
+#      define SET_IOPL() iopl(3)
+#      define RESET_IOPL() iopl(0)
+#    else
+#      define SET_IOPL() (void)0
+#      define RESET_IOPL() (void)0
+#    endif
+#  endif
+#endif
diff --git a/util/mRegs.c b/util/mRegs.c
index f359738..843d01d 100644
--- a/util/mRegs.c
+++ b/util/mRegs.c
@@ -1,63 +1,8 @@
-
-
-
-
-
-
-#ifdef __NetBSD__
-#  include <sys/types.h>
-#  include <machine/pio.h>
-#  include <machine/sysarch.h>
-#else
-#  if defined(SVR4) && defined(i386)
-#    include <sys/types.h>
-#    ifdef NCR
-       /* broken NCR <sys/sysi86.h> */
-#      define __STDC
-#      include <sys/sysi86.h>
-#      undef __STDC
-#    else
-#      include <sys/sysi86.h>
-#    endif
-#    ifdef SVR4
-#      if !defined(sun)
-#        include <sys/seg.h>
-#      endif
-#    endif
-#    include <sys/v86.h>
-#    if defined(sun)
-#      include <sys/psw.h>
-#    endif
-#  endif
-#  include "AsmMacros.h"
-#endif /* NetBSD */
-
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 
-#ifdef __NetBSD__
-#  define SET_IOPL() i386_iopl(3)
-#  define RESET_IOPL() i386_iopl(0)
-#else
-#  if defined(SVR4) && defined(i386)
-#    ifndef SI86IOPL
-#      define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
-#      define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
-#    else
-#      define SET_IOPL() sysi86(SI86IOPL,3)
-#      define RESET_IOPL() sysi86(SI86IOPL,0)
-#    endif
-#  else
-#    ifdef linux
-#      define SET_IOPL() iopl(3)
-#      define RESET_IOPL() iopl(0)
-#    else
-#      define SET_IOPL() (void)0
-#      define RESET_IOPL() (void)0
-#    endif
-#  endif
-#endif
+#include "iopl.h"
 
 int hex2int(char* str);
 
diff --git a/util/modClock.c b/util/modClock.c
index 89a291a..45af19b 100644
--- a/util/modClock.c
+++ b/util/modClock.c
@@ -1,61 +1,12 @@
-
-#ifdef __NetBSD__
-#  include <sys/types.h>
-#  include <machine/pio.h>
-#  include <machine/sysarch.h>
-#else
-#  if defined(SVR4) && defined(i386)
-#    include <sys/types.h>
-#    ifdef NCR
-       /* broken NCR <sys/sysi86.h> */
-#      define __STDC
-#      include <sys/sysi86.h>
-#      undef __STDC
-#    else
-#      include <sys/sysi86.h>
-#    endif
-#    ifdef SVR4
-#      if !defined(sun)
-#        include <sys/seg.h>
-#      endif
-#    endif
-#    include <sys/v86.h>
-#    if defined(sun)
-#      include <sys/psw.h>
-#    endif
-#  endif
-#  include "AsmMacros.h"
-#endif /* NetBSD */
-
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
+
 #ifndef Lynx
 #include <fnmatch.h>
 #endif
 
-#ifdef __NetBSD__
-#  define SET_IOPL() i386_iopl(3)
-#  define RESET_IOPL() i386_iopl(0)
-#else
-#  if defined(SVR4) && defined(i386)
-#    ifndef SI86IOPL
-#      define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
-#      define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
-#    else
-#      define SET_IOPL() sysi86(SI86IOPL,3)
-#      define RESET_IOPL() sysi86(SI86IOPL,0)
-#    endif
-#  else
-#    ifdef linux
-#      define SET_IOPL() iopl(3)
-#      define RESET_IOPL() iopl(0)
-#    else
-#      define SET_IOPL() (void)0
-#      define RESET_IOPL() (void)0
-#    endif
-#  endif
-#endif
+#include "iopl.h"
 
 #define tolerance 0.01 /* +/- 1% */
 
